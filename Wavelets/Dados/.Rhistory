print(paste("RMSE Series =",error))
#50 first
forecast_values=for202$mean
seriesDF = data.frame(original = as.numeric(serie_2for[c(1:50)]),forecasted = forecast_values[c(1:50)])
plot=ggplot(seriesDF,aes(x=c(1:50)))+
ggtitle("Forecast Comparison (50 first) Japan") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Japan_9201_T/Dados_10a19FOR/Forecast50first_Japan.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for[c(1:50)],forecast_values[c(1:50)])
print(paste("RMSE Series =",error))
#New split
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:1768)]
serie_2for=serie[c(1769:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
fit202=arima(serie_ts_2fit, order = c(11,0,24))
fit202=arima(serie_ts_2fit, order = c(2,0,2))
for202=forecast(fit202,h=20,level=c(80,95))
forecast_values=for202$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (20 last) Japan") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Japan_9201_T/Dados_10a19FOR/Forecast20last_Japan.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
#Setar diretório correto
setwd("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ")
#Leitura dos dados
arquivo=read.csv(file="LTMAQ2010a2019.csv")
#Selecionando apenas o AdjClose -> podemos ignorar os outros
AdjClose=arquivo[c(6)]
#Convertendo para numeric a fim de limpar NA e NAN
AdjClose_vec=as.numeric(t(AdjClose))
AdjClose_vec=AdjClose_vec[!is.na(AdjClose_vec)]
AdjClose_vec=AdjClose_vec[!is.nan(AdjClose_vec)]
#Vizualização dos dados originais
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/AdjClose_Latam_10a19.jpeg",width = 658, height = 553)
plot(AdjClose_vec,main="AdjClose Latam 2010-2019",type="l")
dev.off()
#Para obter o log-return a partir dos preços
#Temos que, o retorno rt = ln(Pt)-ln(Pt-1), ou seja, a diferença do log do preço atual e do log do preço em t-1.
#A função diff retorna justamente AdjClose_vec[t]-AdjClose_vec[t-1]
logret=diff(log(AdjClose_vec),lag=1)
logret=logret[!is.na(logret)]
logret=logret[!is.nan(logret)]
#Para vizualizar o retorno, não o preço
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/LogRet_Latam_10a19.jpeg",width = 658, height = 553)
plot(logret,main="Log-return AdjClose Latam 2010-2019",type="l")
dev.off()
#Colocando BA_logret em uma variável do tipo TimeSeries
serie=ts(logret)
serie=tsclean(serie)
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2250)]
serie_2for=serie[c(2251:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
#Plot da série separada para ajuste
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/Serie_Latam_10a19.jpeg",width = 658, height = 553)
plot(serie_ts_2fit,main="Time Serie Log Return AdjClose Latam 2010-2019",type="l")
dev.off()
#Tratando sazonalidade
decomp_serie=decompose(serie_ts_2fit)#nao reconhece nada
#dickey fuller test para estacionaridade
adf.test(serie_ts_2fit, alternative = "stationary")
#PACF e PACF para determinar ordem
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/ACF_Latam_10a19.jpeg",width = 658, height = 553)
Acf(serie_ts_2fit,main='ACF for Log Return AdjClose Latam 2010-2019')#lags relevantes para MA(q) -> 1, 10 e 19
dev.off()
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/PACF_Latam_10a19.jpeg",width = 658, height = 553)
Pacf(serie_ts_2fit,main='PACF for Log Return AdjClose Latam 2010-2019')#lags relevantes para AR(p) -> 1. 10 e 19
dev.off()
#Ajustando com base nas ACF e PACF -> classe FitARMA
fit100=arima(serie_ts_2fit, order = c(1,0,0))
#Vejamos os resíduos, suas médias e acf dos melhores modelos
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/Res(1,0,0)_Latam_10a19.jpeg",width = 658, height = 553)
checkresiduals(fit100)
dev.off()
#Forecasting
for100=forecast(fit100,h=153,level=c(80,95))
for1019=forecast(fit1019,h=153,level=c(80,95))
accuracy(for100,serie_2for)
accuracy(for1019,serie_2for)
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/For(1,0,0)_Latam_10a19.jpeg",width = 658, height = 553)
plot(for100)
dev.off()
#All entries
forecast_values=for100$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (all) Latam") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/ForecastAll_Latam.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
#50 first
forecast_values=for100$mean
seriesDF = data.frame(original = as.numeric(serie_2for[c(1:50)]),forecasted = forecast_values[c(1:50)])
plot=ggplot(seriesDF,aes(x=c(1:50)))+
ggtitle("Forecast Comparison (50 first) Latam") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/Forecast50first_Latam.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for[c(1:50)],forecast_values[c(1:50)])
print(paste("RMSE Series =",error))
#New split
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2383)]
serie_2for=serie[c(2384:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
fit100=arima(serie_ts_2fit, order = c(1,0,0))
for100=forecast(fit100,h=20,level=c(80,95))
forecast_values=for100$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (20 last) Latam") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Latam_LTMAQ/Dados_10a19FOR/Forecast20last_Latam.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
#Setar diretório correto
setwd("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE")
#Leitura dos dados
arquivo=read.csv(file="LHA_DE2010a2019.csv")
#Selecionando apenas o AdjClose -> podemos ignorar os outros
AdjClose=arquivo[c(6)]
#Convertendo para numeric a fim de limpar NA e NAN
AdjClose_vec=as.numeric(t(AdjClose))
AdjClose_vec=AdjClose_vec[!is.na(AdjClose_vec)]
AdjClose_vec=AdjClose_vec[!is.nan(AdjClose_vec)]
#Vizualização dos dados originais
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/AdjClose_Lufthansa_10a19.jpeg",width = 658, height = 553)
plot(AdjClose_vec,main="AdjClose Lufthansa 2010-2019",type="l")
dev.off()
#Para obter o log-return a partir dos preços
#Temos que, o retorno rt = ln(Pt)-ln(Pt-1), ou seja, a diferença do log do preço atual e do log do preço em t-1.
#A função diff retorna justamente AdjClose_vec[t]-AdjClose_vec[t-1]
logret=diff(log(AdjClose_vec),lag=1)
logret=logret[!is.na(logret)]
logret=logret[!is.nan(logret)]
#Para vizualizar o retorno, não o preço
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/LogRet_Lufthansa_10a19.jpeg",width = 658, height = 553)
plot(logret,main="Log-return AdjClose Lufthansa 2010-2019",type="l")
dev.off()
#Colocando BA_logret em uma variável do tipo TimeSeries
serie=ts(logret)
serie=tsclean(serie)
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2400)]
serie_2for=serie[c(2401:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
#Plot da série separada para ajuste
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/Serie_Lufthansa_10a19.jpeg",width = 658, height = 553)
plot(serie_ts_2fit,main="Time Serie Log Return AdjClose Lufthansa 2010-2019",type="l")
dev.off()
#Tratando sazonalidade
decomp_serie=decompose(serie_ts_2fit)#nao reconhece nada
#dickey fuller test para estacionaridade
adf.test(serie_ts_2fit, alternative = "stationary")
#PACF e PACF para determinar ordem
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/ACF_Lufthansa_10a19.jpeg",width = 658, height = 553)
Acf(serie_ts_2fit,main='ACF for Log Return AdjClose Lufthansa 2010-2019')#lags relevantes para MA(q) -> 11 e 21
dev.off()
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/PACF_Lufthansa_10a19.jpeg",width = 658, height = 553)
Pacf(serie_ts_2fit,main='PACF for Log Return AdjClose Lufthansa 2010-2019')#lags relevantes para AR(p) -> 11
dev.off()
#Ajustando com base nas ACF e PACF -> classe FitARMA
fit1100=arima(serie_ts_2fit, order = c(11,0,0))
#Vejamos os resíduos, suas médias e acf dos melhores modelos
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/Res(11,0,0)_Lufthansa_10a19.jpeg",width = 658, height = 553)
checkresiduals(fit1100)
dev.off()
#Forecasting
for1100=forecast(fit1100,h=134,level=c(80,95))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/For(11,0,0)_Lufthansa_10a19.jpeg",width = 658, height = 553)
plot(for1100)
dev.off()
#All entries
forecast_values=for1100$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (all) Lufthansa") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/ForecastAll_Lufthansa.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
#50 first
forecast_values=for1100$mean
seriesDF = data.frame(original = as.numeric(serie_2for[c(1:50)]),forecasted = forecast_values[c(1:50)])
plot=ggplot(seriesDF,aes(x=c(1:50)))+
ggtitle("Forecast Comparison (50 first) Lufthansa") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/Forecast50first_Lufthansa.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for[c(1:50)],forecast_values[c(1:50)])
print(paste("RMSE Series =",error))
#New split
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2514)]
serie_2for=serie[c(2515:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
fit1100=arima(serie_ts_2fit, order = c(11,0,0))
for1100=forecast(fit1100,h=20,level=c(80,95))
forecast_values=for1100$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (20 last) Lufthansa") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/Lufthansa_LHA_DE/Dados_10a19FOR/Forecast20last_Lufthansa.jpeg",width = 658, height = 553)
print(plot)
dev.off()
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
print(plot)
#Setar diretório correto
setwd("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL")
#Leitura dos dados
arquivo=read.csv(file="UAL2010a2019.csv")
#Selecionando apenas o AdjClose -> podemos ignorar os outros
AdjClose=arquivo[c(6)]
#Convertendo para numeric a fim de limpar NA e NAN
AdjClose_vec=as.numeric(t(AdjClose))
AdjClose_vec=AdjClose_vec[!is.na(AdjClose_vec)]
AdjClose_vec=AdjClose_vec[!is.nan(AdjClose_vec)]
#Vizualização dos dados originais
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/AdjClose_United_10a19.jpeg",width = 658, height = 553)
plot(AdjClose_vec,main="AdjClose United 2010-2019",type="l")
dev.off()
#Para obter o log-return a partir dos preços
#Temos que, o retorno rt = ln(Pt)-ln(Pt-1), ou seja, a diferença do log do preço atual e do log do preço em t-1.
#A função diff retorna justamente AdjClose_vec[t]-AdjClose_vec[t-1]
logret=diff(log(AdjClose_vec),lag=1)
logret=logret[!is.na(logret)]
logret=logret[!is.nan(logret)]
#Para vizualizar o retorno, não o preço
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/LogRet_United_10a19.jpeg",width = 658, height = 553)
plot(logret,main="Log-return AdjClose United 2010-2019",type="l")
dev.off()
#Colocando BA_logret em uma variável do tipo TimeSeries
serie=ts(logret)
serie=tsclean(serie)
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2400)]
serie_2for=serie[c(2401:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
#Plot da série separada para ajuste
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/Serie_United_10a19.jpeg",width = 658, height = 553)
plot(serie_ts_2fit,main="Time Serie Log Return AdjClose United 2010-2019",type="l")
dev.off()
#Tratando sazonalidade
decomp_serie=decompose(serie_ts_2fit)#nao reconhece nada
#dickey fuller test para estacionaridade
adf.test(serie_ts_2fit, alternative = "stationary")
#PACF e PACF para determinar ordem
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/ACF_United_10a19.jpeg",width = 658, height = 553)
Acf(serie_ts_2fit,main='ACF for Log Return AdjClose United 2010-2019')#lags relevantes para MA(q) -> 23??
dev.off()
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/PACF_United_10a19.jpeg",width = 658, height = 553)
Pacf(serie_ts_2fit,main='PACF for Log Return AdjClose United 2010-2019')#lags relevantes para AR(p) -> 23
dev.off()
#Ajustando com base nas ACF e PACF -> classe FitARMA
fit2300=arima(serie_ts_2fit, order = c(23,0,0))
fit0023=arima(serie_ts_2fit, order = c(0,0,23))
fit23023=arima(serie_ts_2fit, order = c(23,0,23))
#coeficientes dos modelos
print(fit2300)
#Ajustando com base nas ACF e PACF -> classe FitARMA
fit2300=arima(serie_ts_2fit, order = c(23,0,0))
#Ajustando com base nas ACF e PACF -> classe FitARMA
fit2300=arima(serie_ts_2fit, order = c(23,0,0))
#Vejamos os resíduos, suas médias e acf dos melhores modelos
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/Res(23,0,0)_United_10a19.jpeg",width = 658, height = 553)
checkresiduals(fit2300)
dev.off()
#Forecasting
for2300=forecast(fit2300,h=113,level=c(80,95))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/For(23,0,0)_United_10a19.jpeg",width = 658, height = 553)
plot(for2300)
dev.off()
#All entries
forecast_values=for2300$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (all) United") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/ForecastAll_United.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
#50 first
forecast_values=for2300$mean
seriesDF = data.frame(original = as.numeric(serie_2for[c(1:50)]),forecasted = forecast_values[c(1:50)])
plot=ggplot(seriesDF,aes(x=c(1:50)))+
ggtitle("Forecast Comparison (50 first) United") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/Forecast50first_United.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for[c(1:50)],forecast_values[c(1:50)])
print(paste("RMSE Series =",error))
#New split
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2514)]
serie_2for=serie[c(2515:length(serie))]
#New split
#Separando a serie em uma parte para ajuste do modelo e outra para comparação com previsão
serie_2fit=serie[c(1:2493)]
serie_2for=serie[c(2494:length(serie))]
serie_ts_2fit=ts(serie_2fit)
serie_ts_2for=ts(serie_2for)
fit2300=arima(serie_ts_2fit, order = c(23,0,0))
for2300=forecast(fit2300,h=20,level=c(80,95))
forecast_values=for2300$mean
seriesDF = data.frame(original = as.numeric(serie_2for),forecasted = forecast_values)
plot=ggplot(seriesDF,aes(x=c(1:length(forecast_values))))+
ggtitle("Forecast Comparison (20 last) United") +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
jpeg(file="C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Modelos/United_UAL/Dados_10a19FOR/Forecast20last_United.jpeg",width = 658, height = 553)
print(plot)
dev.off()
print(plot)
error = rmse(serie_2for,forecast_values)
print(paste("RMSE Series =",error))
library(forecast)
library(tseries)
library(WaveletArima)
library(Metrics)
library(ggplot2)
#Set correct directory -> must be careful
setwd("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Wavelets")
#Importing the data
setwd("Dados")
arquivo_IAG=read.csv(file="IAG_L2010a2019.csv")
arquivo_Japan=read.csv(file="9201_T2010a2019.csv")
arquivo_ChinaSouth=read.csv(file="1055_HK2010a2019.csv")
arquivo_ChinaEast=read.csv(file="0670_HK2010a2019.csv")
arquivo_Latam=read.csv(file="LTMAQ2010a2019.csv")
arquivo_Delta=read.csv(file="DAL2010a2019.csv")
arquivo_United=read.csv(file="UAL2010a2019.csv")
arquivo_American=read.csv(file="AAL2010a2019.csv")
arquivo_Luft=read.csv(file="LHA_DE2010a2019.csv")
arquivo_AirFranceKLM=read.csv(file="AF_PA2010a2019.csv")
AdjClose_IAG=arquivo_IAG[c(6)]
AdjClose_Japan=arquivo_Japan[c(6)]
AdjClose_IAG=arquivo_IAG[c(6)]
AdjClose_Japan=arquivo_Japan[c(6)]
AdjClose_ChinaEast=arquivo_ChinaEast[c(6)]
AdjClose_ChinaSouth=arquivo_ChinaSouth[c(6)]
AdjClose_Delta=arquivo_Delta[c(6)]
AdjClose_United=arquivo_United[c(6)]
AdjClose_American=arquivo_American[c(6)]
AdjClose_Luft=arquivo_Luft[c(6)]
AdjClose_Latam=arquivo_Latam[c(6)]
AdjClose_AirFranceKLM=arquivo_AirFranceKLM[c(6)]
#Putting all of them in a vector in order to make th code cleaner
AdjClose = c(AdjClose_IAG,AdjClose_Japan,AdjClose_ChinaSouth,AdjClose_ChinaEast,AdjClose_Latam,AdjClose_Delta,AdjClose_United,AdjClose_American,AdjClose_Luft,AdjClose_AirFranceKLM)
len=length(AdjClose)
names=c("IAG","Japan","ChinaSouth","ChinaEast","Latam","Delta","United","American","Lufthansa","AirFranceKLM")
for (i in 1:len) {
AdjClose[[i]]=as.numeric(t(AdjClose[[i]]))
AdjClose[[i]]=AdjClose[[i]][!is.na(AdjClose[[i]])]
AdjClose[[i]]=AdjClose[[i]][!is.nan(AdjClose[[i]])]
}
#Visualizing the original data
for(i in 1:len){
path = paste("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Wavelets/Imagens/",names[i],"/AdjClose_",names[i],".jpeg",sep = "")
jpeg(file=path,width = 658, height = 553)
plot(AdjClose[[i]],main=paste("AdjClose",names[i]),type="l")
dev.off()
}
#Converting to TimeSeries class
series=c()
for (i in 1:len) {
series[[i]]=ts(AdjClose[[i]])
series[[i]]=tsclean(series[[i]])
}
#Checking if it is stationary -> seems not
tests=c()
for(i in 1:len){
print(names[i])
tests[[i]]=adf.test(series[[i]], alternative = "stationary")
print(tests[[i]])
}
#We are interested in the log-return, not the price itself. Let's calculate it
#We have rt = ln(Pt)-ln(Pt-1)
logret=c()
for(i in 1:len){
logret[[i]]=diff(log(series[[i]]),lag=1)
logret[[i]]=logret[[i]][!is.na(logret[[i]])]
logret[[i]]=logret[[i]][!is.nan(logret[[i]])]
logret[[i]]=ts(logret[[i]])
logret[[i]]=tsclean(logret[[i]])
}
#Let's check stationarity againg, since we have made a differentiation
tests_logret=c()
for(i in 1:len){
print(names[i])
tests_logret[[i]]=adf.test(logret[[i]], alternative = "stationary")
print(tests_logret[[i]])
}
#Visualizing the series after the log-return
for(i in 1:len){
path = paste("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Wavelets/Imagens/",names[i],"/Logret_",names[i],".jpeg",sep = "")
jpeg(file=path,width = 658, height = 553)
plot(logret[[i]],main=paste("LogReturn",names[i]),type="l")
dev.off()
}
#Train and test -> we will make 90%/10%
serie_2fit=c()
serie_2for=c()
wave=c()
forecast_values=c()
for(i in 1:len){
train_limit=as.integer(0.9*length(logret[[i]]))
serie_2fit[[i]]=ts(logret[[i]][c(1:train_limit)])
serie_2for[[i]]=ts(logret[[i]][c((train_limit+1):length(logret[[i]]))])
#Fitting and Forecasting with Wavelets + ARIMA
levels = floor(log(length(serie_2fit[[i]])))
wave[[i]] = WaveletFittingarma(logret[[i]],Waveletlevels=levels,boundary='periodic',FastFlag=TRUE,NForecast = length(serie_2for[[i]]),MaxARParam = 15,MaxMAParam = 15)
forecast_values[[i]] = wave[[i]]$Finalforecast
#Calculating the Root Mean Square Error
error = rmse(serie_2for[[i]],forecast_values[[i]])
print(paste("RMSE Series",names[i],"=",error))
}
#All of them
for (i in 1:len) {
seriesDF = data.frame(original = as.numeric(serie_2for[[i]]),forecasted = forecast_values[[i]])
plot=ggplot(seriesDF,aes(x=c(1:length(serie_2for[[i]])))) +
ggtitle(paste("Forecast Comparison (All)",names[i])) +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
path = paste("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Wavelets/Imagens/",names[i],"/ForecastAll_",names[i],".jpeg",sep = "")
jpeg(file=path,width = 658, height = 553)
print(plot)
dev.off()
error = rmse(serie_2for[[i]],forecast_values[[i]])
print(paste("RMSE Series",names[i],"=",error))
}
#Only the 50 first
for (i in 1:len) {
seriesDF = data.frame(original = as.numeric(serie_2for[[i]][c(1:50)]),forecasted = forecast_values[[i]][c(1:50)])
plot=ggplot(seriesDF,aes(x=c(1:50)))+
ggtitle(paste("Forecast Comparison (50 first)",names[i])) +
geom_line(aes(y = original, colour = "original")) +
geom_line(aes(y = forecasted, colour = "predicted"))
path = paste("C:/Users/matno_5/OneDrive/Área de Trabalho/PUC/IC/GitPrivado/IC/Wavelets/Imagens/",names[i],"/Forecast50_",names[i],".jpeg",sep = "")
jpeg(file=path,width = 658, height = 553)
print(plot)
dev.off()
serie_2for_50=serie_2for[[i]]
serie_2for_50=serie_2for_50[c(1:50)]
forecast_values_50=forecast_values[[i]]
forecast_values_50=forecast_values_50[c(1:50)]
error = rmse(serie_2for_50,forecast_values_50)
print(paste("RMSE Series (50 first)",names[i],"=",error))
}
#Train and test -> we will leave just 20 entries to forecast
serie_2fit=c()
serie_2for=c()
wave=c()
forecast_values=c()
for(i in 1:len){
train_limit=length(logret[[i]])-20
serie_2fit[[i]]=ts(logret[[i]][c(1:train_limit)])
serie_2for[[i]]=ts(logret[[i]][c((train_limit+1):length(logret[[i]]))])
#Fitting and Forecasting with Wavelets + ARIMA
levels = floor(log(length(serie_2fit[[i]])))
wave[[i]] = WaveletFittingarma(logret[[i]],Waveletlevels=levels,boundary='periodic',FastFlag=TRUE,NForecast = length(serie_2for[[i]]),MaxARParam = 15,MaxMAParam = 15)
forecast_values[[i]] = wave[[i]]$Finalforecast
#Calculating the Root Mean Square Error
error = rmse(serie_2for[[i]],forecast_values[[i]])
print(paste("RMSE Series",names[i],"=",error))
}
